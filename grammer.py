#! /bin/python3

from pathlib  import Path
from argparse import ArgumentParser
from typing   import List, Tuple

class class_file:
    def __init__(self, class_name: str, arg_list: List[Tuple[str, str]], header_file: Path, source_file: Path):
        self._class_name = f'{class_name}expression'
        self._header_file = header_file
        self._source_file = source_file
        self._arg_list = arg_list

        self._gen_arg_strings()
        self._gen_header()
        self._gen_source()

    def _gen_arg_strings(self) -> None:
        self._arg_strings = []
        for a in self._arg_list:
            self._arg_strings.append(f'std::shared_ptr<{a[0]}> {a[1]}')

    def _gen_header(self) -> str:
        header_text = f"""
/**
 * This file is generated by {__file__}. Make changes there and not to this file directly. 
 */

#ifndef {self._class_name.upper()}_H
#define {self._class_name.upper()}_H

#include <string>
#include <memory>

#include "expression/expression.h"
"""
        for a in self._arg_list:
            if a[0] == 'token':
                header_text += '#include "tokens/token.h"\n'
            elif a[0] == 'object':
                header_text += '#include "types/object.h"\n'

        header_text += f'\nclass {self._class_name}: public expression\n'
        header_text += '{\n\npublic:\n\n'
        header_text += f'    {self._class_name}('

        for i in range(len(self._arg_strings)):
            header_text += self._arg_strings[i]
            if i + 1 < len(self._arg_strings):
                header_text += ', '  
        header_text += ');'  
        header_text += f"""
    {self._class_name}(const {self._class_name} &other);
    ~{self._class_name}(); 

    virtual std::string to_string() const; 
    virtual std::string type_name() const;  

private:      
"""
        for astring in self._arg_strings:
            header_text += f'    {astring};\n'
        header_text += '\n};\n\n#endif'
        
        with open(self._header_file, 'w') as header:
            header.write(header_text)

    def _gen_source(self) -> None:
        source_text = f"""
/**
 * This file is generated by {__file__}. Make changes there and not to this file directly. 
 */

#include <sstream>

#include "{self._header_file}"

{self._class_name}::{self._class_name}("""


        for i in range(len(self._arg_strings)):
            source_text += self._arg_strings[i]
            if i + 1 < len(self._arg_strings):
                source_text += ', ' 
        source_text += '):\n'         
        for i in range(len(self._arg_list)):
            source_text += f'    {self._arg_list[i][1]}({self._arg_list[i][1]})'
            if i + 1 < len(self._arg_list):
                source_text += ','
            source_text += '\n' 
        source_text += '{\n\n}\n\n'
        source_text += f'{self._class_name}::{self._class_name}(const {self._class_name} &other):\n'
        for i in range(len(self._arg_list)):
            source_text += f'    {self._arg_list[i][1]}(other.{self._arg_list[i][1]})'
            if i + 1 < len(self._arg_list):
                source_text += ','
            source_text += '\n'  
        source_text += '{\n\n}\n\n'   
        source_text += f'{self._class_name}::~{self._class_name}()\n'
        source_text += '{\n\n}\n\n'       

        source_text += f'std::string {self._class_name}::to_string() const\n' 
        source_text += """{
    std::stringstream stream;
    stream <<"""
        
        for i in range(len(self._arg_list)):
            source_text += f' *(this->{self._arg_list[i][1]})'
            if i + 1 < len(self._arg_list):
                source_text += '<< " " <<'
        source_text += ';'          

        source_text += """
    return stream.str();
}

"""

        source_text += f'std::string {self._class_name}::type_name() const\n'
        source_text += '{\n'
        source_text += f'    return "{self._class_name}";\n'
        source_text += '}\n'  

        with open(self._source_file, 'w') as source:
            source.write(source_text)

    def __str__(self):
        return f'{self._class_name}:\n\t{self._header_file}\n\t{self._source_file}' 

def parse_expression(line: str, header_dir: Path, source_dir: Path) -> class_file:
    line_data = line.split(':')
    class_name = line_data[0].strip()
    header_file = header_dir/f'{class_name}.h'
    source_file = source_dir/f'{class_name}.cpp'
    arg_list = []

    def_data = line_data[1].strip().split(',')
    def_data = [ arg.strip() for arg in def_data]
    for arg in def_data:
        a = arg.split(' ')
        arg_list.append((a[0].strip(), a[1].strip()))
    return class_file(class_name, arg_list, header_file, source_file)

def parse_grammer_file(grammer_file: Path, header_dir: Path, source_dir: Path) -> List[class_file]:
    ret = []
    with open(grammer_file, 'r') as gf:
        for entry in gf:
            ret.append(parse_expression(entry, header_dir, source_dir))
    return ret

def remove_dir(dir_path: Path) -> None:
    if dir_path.exists():
        for file in dir_path.iterdir():
            if file.is_dir():
                remove_dir(file)
            else:
                file.unlink()
        dir_path.rmdir()

if __name__ == "__main__":

    parser = ArgumentParser(prog='grammer', description="parse grammer")
    parser.add_argument('--clean', '-c', 
                        action='store_true',
                        help="clean")
    args = parser.parse_args()

    grammer_file = Path('.').resolve()/'grammer'
    include_dir = Path('.').resolve()/'include'/'generated'
    source_dir = Path('.').resolve()/'source'/'generated'

    if args.clean:
        remove_dir(include_dir)
        remove_dir(source_dir)
        exit(0)

    if not include_dir.exists():
        include_dir.mkdir()
    if not source_dir.exists():
        source_dir.mkdir()

    parse_grammer_file(grammer_file, include_dir, source_dir)
    exit(0)